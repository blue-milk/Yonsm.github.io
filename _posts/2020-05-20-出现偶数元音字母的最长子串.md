---
date : 2020-05-20 12:30:01+00:00
layout : post
title : 出现偶数元音字母的最长子串
categories : Leetcode
tags : 前缀和
---

### 题目简介
给你一个字符串 s ，请你返回满足以下条件的最长子字符串的长度：每个元音字母，即 'a'，'e'，'i'，'o'，'u' ，在子字符串中都恰好出现了偶数次。

### 思路
* 1 暴力算法：

枚举所有子串，遍历子串中的所有字符，统计元音字母出现的个数。如果符合条件就更新答案。但这样时间复杂度为O（n^3）

* 2 前缀和：

定义 pre[i][k] 为前i个字符中，第k个元音字母出现的次数，那么为了判断[j...i]之间的子串是否符合要求，我们可以用pre[i][k] - pre[j-1][k] 计算对于每个k的元音字母的次数，判断是否为偶数。但是这样依旧要以O(n^2)的时间复杂度遍历子串

为了进一步优化，我们可以试着用「和为k的子数组」中的方法，也就是前缀和+哈希表，用哈希表来存储以i结尾的子串中每个元音字母出现的次数，一边更新哈希表一边判断是否存在符合条件的子串。在「和为k的子数组」中，利用此方法寻找的子串需要满足的条件是pre[i]和pre[j-1]之间的和相差k，但是在本题中，pre[i]和pre[j-1]之间并没有直接的恒等关系，那怎么办呢？

题目的要求是子串中元音字母都出现**偶数次**，即pre[i][k] - pre[j-1][k] 要为偶数，那么pre[i][k] 和 pre[j-1][k] 一定具有相同的奇偶性(奇数-奇数=偶数，偶数-偶数=偶数)，这就是本题的判断依据。

### 状态压缩
根据判断依据，我们只需要用哈希表存储前i子串每个元音字母出现次数的奇偶性就可以了。为此，我们可以优化我们的编码：用1表示奇数状态，0表示偶数状态，uoiea对应的就是一个5位2进制数，我们将之转化为十进制数，即可对应前i子串的状态。例如，假设前i个子串中，uoiea出现次数的奇偶性为：01001，则我们用9作为这个前i子串的哈希。由此可知，元音字母出现次数的奇偶性相同的前i子串拥有相同的十进制数。

既然如此，我们就可以不用哈希表了，直接用一个数组表示即可：

uoiea对应的状态为[00000,11111],也就是十进制[0,31]

用一个32位的state数组，数组下标表示uoiea的状态，数组所存的数是字符串的前i子串对应uoiea状态的索引i，例如字符串的前5子串uoiea出现次数的奇偶性为01001，那么state[9]存入5.

### python 实现
```python
class Solution:
    def findTheLongestSubstring(self, s: str) -> int:
        res = 0
        state = [-1] * (1<<5)  
        d = dict(zip('uoiea',range(5))) #{'u':4,'0':3,'i':2,'e':1,'a':0}
        j, state[0] = 0, 0
        for idx,val in enumerate(s):
            tmp = -1
            if val in d:
                tmp = d[val]  
            if tmp != -1:
            #按位异或，未异或前的cur是上一个前i子串的元音字母状态
                j ^= 1<<tmp  
            
            if state[j] == -1:
            #如果没有发现相同的状态，就存入当前的前i子串的索引
                state[j] = idx + 1
            else:
            #如果发现相同状态，则表示找到符合条件的子串，计算子串的长度
                res = max(res,idx-state[j]+1)
        return res
```

### 移位运算：
1<<5 : 1向左移5位，低位补0，高位舍弃。



