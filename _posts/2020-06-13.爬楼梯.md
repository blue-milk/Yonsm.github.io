---
date : 2020-06-13 10:30:01+00:00
layout : post
title : 爬楼梯
categories : Leetcode
tags : 动态规划
---

这是道简单题，然鹅我的思路一开始就严重跑偏偏偏偏。。。

### 题目简介

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

### 动态规划
设f(x)为爬x阶的方案，由于最后一步可以跨1阶也可以跨2阶，所以：
> f(x) = f(x-1) + f(x-2)

这是啥？斐波那契数！！！

### 加入滚动数组
一般斐波那契都用递归求，但复杂度好高。由于要求的项只和最后两项有关，所以利用滚动数组。

### python实现
```python
class Solution:
    def climbStairs(self, n: int) -> int:
        x,y = 0,1
        for _ in range(n):
            x, y = y, x+y
        return y
```

### 总结

这里形成的数列正好是斐波那契数列，答案要求的 f(n) 即是斐波那契数列的第 n 项（下标从 0 开始）。我们来总结一下斐波那契数列第 n 项的求解方法：

* n 比较小的时候，可以直接使用过递归法求解，不做任何记忆化操作，时间复杂度是 O(2^n)，存在很多冗余计算。
* 一般情况下，我们使用「记忆化搜索」或者「迭代」的方法，实现这个转移方程，时间复杂度和空间复杂度都可以做到 O(n)。
* 为了优化空间复杂度，我们可以不用保存 f(x−2) 之前的项，我们只用三个变量来维护 f(x)、f(x−1) 和 f(x−2)，你可以理解成是把「滚动数组思想」应用在了动态规划中，也可以理解成是一种递推，这样把空间复杂度优化到了 O(1)。
* 随着 n 的不断增大 O(n) 可能已经不能满足我们的需要了，我们可以用「矩阵快速幂」的方法把算法加速到 O(logn)。
* 我们也可以把 n 代入斐波那契数列的通项公式计算结果，但是如果我们用浮点数计算来实现，可能会产生精度误差。





